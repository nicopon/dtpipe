using Testcontainers.MsSql;
using Xunit;
using Microsoft.Data.SqlClient;
using QueryDump.Adapters.SqlServer;
using QueryDump.Adapters;
using QueryDump.Adapters.Parquet;
using QueryDump.Tests.Helpers;

namespace QueryDump.Tests;

/// <summary>
/// Integration tests using SQL Server Testcontainers.
/// </summary>
[Trait("Category", "Integration")]
[Collection("Docker Integration Tests")]
public class SqlServerIntegrationTests : IAsyncLifetime
{
    private MsSqlContainer? _sqlServer;

    public async ValueTask InitializeAsync()
    {
        if (!DockerHelper.IsAvailable())
        {
            return;
        }

        try
        {
            _sqlServer = new MsSqlBuilder("mcr.microsoft.com/mssql/server:2022-latest").Build();
            await _sqlServer.StartAsync();
            
            await using var connection = new SqlConnection(_sqlServer.GetConnectionString());
            await connection.OpenAsync();
            
            // Use Seeder for DDL and Data
            await using var cmd = connection.CreateCommand();
            cmd.CommandText = TestDataSeeder.GenerateTableDDL(connection, "test_data");
            await cmd.ExecuteNonQueryAsync();

            await TestDataSeeder.SeedAsync(connection, "test_data");
        }
        catch (Exception)
        {
            _sqlServer = null;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_sqlServer is not null)
        {
            await _sqlServer.DisposeAsync();
        }
    }

    [Fact]
    public async Task SqlServerStreamReader_ReadsAllRows()
    {
        if (!DockerHelper.IsAvailable() || _sqlServer is null) return;

        // Arrange
        var connectionString = _sqlServer.GetConnectionString();
        
        // Act
        await using var reader = new SqlServerStreamReader(
            connectionString, 
            "SELECT * FROM test_data ORDER BY Id");
        
        await reader.OpenAsync(TestContext.Current.CancellationToken);
        
        var rows = new List<object?[]>();
        await foreach (var batch in reader.ReadBatchesAsync(10, TestContext.Current.CancellationToken))
        {
            for(int i = 0; i < batch.Length; i++)
            {
                rows.Add(batch.Span[i]);
            }
        }
        
        // Assert
        Assert.Equal(4, rows.Count); // 4 records in test-data.json
        Assert.Equal(7, reader.Columns!.Count); // 7 columns
        Assert.Equal("Id", reader.Columns[0].Name);
        
        // Specific data validation (diverse types)
        var alice = rows.First(r => r[0]?.ToString() == "1");
        Assert.Equal(true, alice[3]); // IsActive (bool/bit)
        Assert.Equal(95.50m, alice[4]); // Score (decimal)
    }

    [Fact]
    public async Task ParquetWriter_CreatesValidFile_FromSqlServer()
    {
        if (!DockerHelper.IsAvailable() || _sqlServer is null) return;

        // Arrange
        var connectionString = _sqlServer.GetConnectionString();
        var outputPath = Path.Combine(Path.GetTempPath(), $"test_sql_{Guid.NewGuid()}.parquet");
        
        try
        {
            // Act
            await using var reader = new SqlServerStreamReader(
                connectionString, 
                "SELECT * FROM test_data ORDER BY Id");
            
            await reader.OpenAsync(TestContext.Current.CancellationToken);
            
            await using var writer = new ParquetDataWriter(outputPath);
            await writer.InitializeAsync(reader.Columns!, TestContext.Current.CancellationToken);
            
            var rows = new List<object?[]>();
            await foreach (var batchChunk in reader.ReadBatchesAsync(100, TestContext.Current.CancellationToken))
            {
                 for(int i = 0; i < batchChunk.Length; i++)
                {
                    rows.Add(batchChunk.Span[i]);
                }
            }
            
            await writer.WriteBatchAsync(rows, TestContext.Current.CancellationToken);
            await writer.CompleteAsync(TestContext.Current.CancellationToken);
            
            // Assert
            Assert.True(File.Exists(outputPath));
            Assert.True(new FileInfo(outputPath).Length > 0);
        }
        finally
        {
            if (File.Exists(outputPath))
                File.Delete(outputPath);
        }
    }
}
