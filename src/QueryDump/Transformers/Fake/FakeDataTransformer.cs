using System.Text.RegularExpressions;
using Bogus;
using QueryDump.Core;
using QueryDump.Core.Options;

namespace QueryDump.Transformers.Fake;

/// <summary>
/// Transforms data rows by replacing specified columns with fake data generated by Bogus.
/// Supports column references using {{COLUMN_NAME}} syntax for composing values.
/// </summary>
public sealed partial class FakeDataTransformer : IDataTransformer, IRequiresOptions<FakeOptions>
{
    public int Priority => 30; // Faker runs after Null (10) and Static (20)

    private readonly Dictionary<string, string> _mappings = new(StringComparer.OrdinalIgnoreCase);
    private readonly FakerRegistry _registry;
    private readonly Faker _faker;
    
    // Regex to match {{COLUMN_NAME}} patterns - compiled once for performance
    [GeneratedRegex(@"\{\{([^}]+)\}\}", RegexOptions.Compiled)]
    private static partial Regex TemplatePattern();
    
    // State initialized in InitializeAsync - built once, reused for all rows
    private int[]? _generationOrder;  // Indices in order of generation (dependencies first)
    private ColumnProcessor[]? _processors;  // Pre-built processors for each column
    private Dictionary<string, int>? _columnNameToIndex;  // Fast lookup for template substitution

    public FakeDataTransformer(FakeOptions options)
    {
        _registry = new FakerRegistry();
        _faker = options.Seed.HasValue 
            ? new Faker(options.Locale) { Random = new Randomizer(options.Seed.Value) } 
            : new Faker(options.Locale);

        if (options.Mappings is not null)
        {
            foreach (var mapping in options.Mappings)
            {
                ParseMapping(mapping);
            }
        }
    }

    /// <summary>
    /// Indicates whether any column mappings are configured.
    /// </summary>
    public bool HasMappings => _mappings.Count > 0;

    /// <summary>
    /// Get the FakerRegistry for listing available fakers.
    /// </summary>
    public FakerRegistry Registry => _registry;

    public ValueTask InitializeAsync(IReadOnlyList<ColumnInfo> columns, CancellationToken ct = default)
    {
        if (!HasMappings)
        {
            _processors = null;
            _generationOrder = null;
            return ValueTask.CompletedTask;
        }

        // Build column name to index map (once)
        _columnNameToIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < columns.Count; i++)
        {
            _columnNameToIndex[columns[i].Name] = i;
        }

        // Build processors for each mapped column
        _processors = new ColumnProcessor[columns.Count];
        var templateColumns = new List<int>();
        var nonTemplateColumns = new List<int>();

        for (var i = 0; i < columns.Count; i++)
        {
            var colName = columns[i].Name;
            
            if (!_mappings.TryGetValue(colName, out var fakerPath))
            {
                continue;
            }

            // Check if this is a template (contains {{...}})
            if (IsTemplate(fakerPath))
            {
                // Extract referenced column names for dependency checking
                var referencedColumns = ExtractReferencedColumns(fakerPath);
                _processors[i] = new ColumnProcessor(i, fakerPath, referencedColumns);
                templateColumns.Add(i);
            }
            else
            {
                // Regular faker or hardcoded string
                var generator = BuildGenerator(fakerPath, colName);
                _processors[i] = new ColumnProcessor(i, generator);
                nonTemplateColumns.Add(i);
            }
        }

        // Build generation order: non-templates first, then templates
        // For now, simple ordering. Future: topological sort for nested templates
        _generationOrder = new int[nonTemplateColumns.Count + templateColumns.Count];
        var idx = 0;
        foreach (var col in nonTemplateColumns)
        {
            _generationOrder[idx++] = col;
        }
        foreach (var col in templateColumns)
        {
            _generationOrder[idx++] = col;
        }

        return ValueTask.CompletedTask;
    }

    public ValueTask<IReadOnlyList<object?[]>> TransformAsync(IReadOnlyList<object?[]> rows, CancellationToken ct = default)
    {
        if (_processors is null || _generationOrder is null || rows.Count == 0)
        {
            return new ValueTask<IReadOnlyList<object?[]>>(rows);
        }

        // In-place modification
        foreach (var row in rows)
        {
            // Process columns in dependency order
            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate)
                {
                    // Template: substitute {{COL}} with already-generated values
                    row[colIdx] = SubstituteTemplate(processor.Template!, row);
                }
                else if (processor.Generator is not null)
                {
                    // Faker or hardcoded
                    row[colIdx] = processor.Generator(_faker);
                }
            }
        }

        return new ValueTask<IReadOnlyList<object?[]>>(rows);
    }

    private static bool IsTemplate(string value) => value.Contains("{{");

    private static HashSet<string> ExtractReferencedColumns(string template)
    {
        var matches = TemplatePattern().Matches(template);
        var result = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private string SubstituteTemplate(string template, object?[] row)
    {
        return TemplatePattern().Replace(template, match =>
        {
            var colName = match.Groups[1].Value;
            if (_columnNameToIndex!.TryGetValue(colName, out var idx))
            {
                return row[idx]?.ToString() ?? string.Empty;
            }
            // Column not found - keep original placeholder with warning logged once during init
            return match.Value;
        });
    }

    private Func<Faker, object?>? BuildGenerator(string fakerPath, string colName)
    {
        var generator = _registry.GetGenerator(fakerPath.ToLowerInvariant());
        
        if (generator is not null)
        {
            return generator;
        }

        // Check if it was supposed to be a faker (valid dataset)
        var parts = fakerPath.Split('.', 2);
        var dataset = parts.Length > 0 ? parts[0] : "";
        
        if (_registry.HasDataset(dataset))
        {
            throw new InvalidOperationException($"Unknown faker method '{fakerPath}' for column '{colName}'. Use --fake-list to see available options.");
        }

        // Hardcoded string fallback
        return _ => fakerPath;
    }

    private void ParseMapping(string mapping)
    {
        // Format: COLUMN:dataset.method or COLUMN:{{OTHER_COLUMN}} template
        var separatorIndex = mapping.IndexOf(':');
        if (separatorIndex <= 0 || separatorIndex >= mapping.Length - 1)
        {
            Console.Error.WriteLine($"Warning: Invalid mapping format '{mapping}'. Expected 'COLUMN:value'");
            return;
        }

        var column = mapping[..separatorIndex].Trim();
        var value = mapping[(separatorIndex + 1)..].Trim();

        if (string.IsNullOrEmpty(column) || string.IsNullOrEmpty(value))
        {
            Console.Error.WriteLine($"Warning: Invalid mapping '{mapping}'. Column and value cannot be empty.");
            return;
        }

        // For templates, store as-is
        if (IsTemplate(value))
        {
            _mappings[column] = value;
            return;
        }

        // For fakers/strings, apply existing validation logic
        var parts = value.Split('.', 2);
        var datasetName = parts.Length > 0 ? parts[0] : string.Empty;

        if (_registry.HasDataset(datasetName))
        {
            if (!_registry.HasGenerator(value))
            {
                throw new InvalidOperationException($"Unknown faker method '{value}' for dataset '{datasetName}'. Use --fake-list to see available options.");
            }
            _mappings[column] = value;
        }
        else if (value.Contains(':'))
        {
             // Fallback: User might have used colon instead of dot (e.g. "finance:iban")
             var normalized = value.Replace(':', '.');
             if (_registry.HasGenerator(normalized))
             {
                 _mappings[column] = normalized;
             }
             else
             {
                 // Not a known faker even after normalization, treat as string
                 _mappings[column] = value;
             }
        }
        else
        {
            // Hardcoded string
            _mappings[column] = value;
        }
    }

    /// <summary>
    /// Holds pre-computed processing info for a column.
    /// </summary>
    private readonly struct ColumnProcessor
    {
        public readonly int Index;
        public readonly Func<Faker, object?>? Generator;
        public readonly string? Template;
        public readonly HashSet<string>? ReferencedColumns;

        public bool IsTemplate => Template is not null;

        // Constructor for faker/hardcoded
        public ColumnProcessor(int index, Func<Faker, object?>? generator)
        {
            Index = index;
            Generator = generator;
            Template = null;
            ReferencedColumns = null;
        }

        // Constructor for template
        public ColumnProcessor(int index, string template, HashSet<string> referencedColumns)
        {
            Index = index;
            Generator = null;
            Template = template;
            ReferencedColumns = referencedColumns;
        }
    }
}

